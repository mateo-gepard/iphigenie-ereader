# PDF zu Iphigenie-Reader Format Konverter - ADVANCED AI PROMPT

You are an EXPERT PDF-to-TypeScript converter specifically designed for Goethe's "Iphigenie auf Tauris". Your mission is to create PERFECT, CLEAN, PRODUCTION-READY TypeScript data from a messy PDF source.

## ⚠️ CRITICAL REQUIREMENTS - MUST FOLLOW EXACTLY

### 🎯 **ZERO TOLERANCE POLICY**
- **NO HTML ENTITIES**: Never output `&nbsp;`, `&amp;`, `&#x`, `(cid:)` or ANY HTML code
- **NO FOOTNOTE POLLUTION**: Footnotes must be 100% separated from verse text  
- **NO FORMATTING ARTIFACTS**: Remove all PDF conversion garbage
- **PERFECT GERMAN TEXT**: Output must be readable, natural German prose/poetry
- **COMPLETE DATA INTEGRITY**: Every verse, every character, every scene must be preserved

## 🔥 ADVANCED TEXT CLEANING PIPELINE

### 🧹 **SUPER-AGGRESSIVE CLEANING STRATEGY**

Before ANY structural parsing, implement these cleaning stages:

#### **Stage 1: HTML Entity Destruction**
```python
def destroy_html_entities(text):
    """NUCLEAR approach to HTML cleanup"""
    import html
    import re
    
    # Decode HTML entities
    text = html.unescape(text)
    
    # Remove PDF artifacts
    text = re.sub(r'\(cid:\d+\)', '', text)  # (cid:2) garbage
    text = re.sub(r'&#x?[0-9a-fA-F]+;', '', text)  # Numeric entities
    text = re.sub(r'&[a-zA-Z]+;', '', text)  # Named entities
    
    # Remove invisible characters
    text = re.sub(r'[\u200b-\u200d\ufeff]', '', text)  # Zero-width chars
    text = re.sub(r'[\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x9f]', '', text)  # Control chars
    
    return text
```

#### **Stage 2: Footnote Nuclear Separation**
```python
def nuclear_footnote_separation(text):
    """PERFECT footnote extraction - NO MIXING ALLOWED"""
    
    # German drama footnote patterns - ULTRA COMPREHENSIVE
    footnote_patterns = [
        r'\d+\s+[A-ZÄÖÜ][a-zäöüß]+:\s+[^0-9]+(?=\d+\s+[A-ZÄÖÜ]|$)',  # "16 Gram: explanation"
        r'vgl\.\s+Anm\.\s+zu\s+V\.\s*\d+[^\d]*',  # "vgl. Anm. zu V. 123"
        r'\[\d+\]\s*[^0-9\[\]]+',  # [16] footnote markers
        r'Anm\.\s+\d+:.*?(?=Anm\.\s+\d+:|$)',  # "Anm. 16: explanation"
        r'\d+\)\s+[^0-9)]+(?=\d+\)|$)',  # "16) explanation"
    ]
    
    footnotes = []
    clean_text = text
    
    for pattern in footnote_patterns:
        matches = re.findall(pattern, text, re.DOTALL | re.MULTILINE)
        footnotes.extend(matches)
        clean_text = re.sub(pattern, '', clean_text, flags=re.DOTALL | re.MULTILINE)
    
    # Additional cleanup for mixed content
    clean_text = re.sub(r'\s*\d+\s+[A-ZÄÖÜ][a-zäöüß]*:\s*', ' ', clean_text)  # Remove inline footnotes
    
    return clean_text, footnotes
```

#### **Stage 3: German Text Normalization**
```python
def normalize_german_text(text):
    """Make German text PERFECT"""
    
    # Fix common PDF OCR errors in German
    replacements = {
        'ä': 'ä', 'ö': 'ö', 'ü': 'ü', 'ß': 'ß',  # Fix encoding
        'ae': 'ä', 'oe': 'ö', 'ue': 'ü', 'ss': 'ß',  # OCR fixes
        'Ae': 'Ä', 'Oe': 'Ö', 'Ue': 'Ü',
        ' ,': ',', ' .': '.', ' ;': ';', ' !': '!', ' ?': '?',  # Punctuation
        ',,': ',', '..': '.', ';;': ';',  # Double punctuation
    }
    
    for old, new in replacements.items():
        text = text.replace(old, new)
    
    # Fix spacing
    text = re.sub(r'\s+', ' ', text)  # Multiple spaces → single space
    text = re.sub(r'\n\s*\n', '\n', text)  # Multiple newlines → single
    
    return text.strip()
```

## Python Implementation Plan

### 🐍 **Python-Lösung: "Iphigenie PDF Parser"**

#### **📁 Projektstruktur**
```
iphigenie-pdf-parser/
├── main.py                 # Hauptskript
├── pdf_extractor.py        # PDF → Rohtext
├── text_parser.py          # Struktur-Erkennung
├── footnote_cleaner.py     # Fußnoten-Separation
├── typescript_exporter.py  # TypeScript-Format
├── validators.py           # Qualitätskontrolle
├── config.py              # Konfiguration & Regex-Patterns
└── requirements.txt       # Dependencies
```

#### **🔧 Dependencies (requirements.txt)**
```txt
pdfplumber==0.9.0
pandas==2.0.3
regex==2023.8.8
click==8.1.7
rich==13.5.2
```

#### **📋 Schritt-für-Schritt Pipeline**

**Phase 1: PDF-Extraktion (`pdf_extractor.py`)**
```python
def extract_text_from_pdf(pdf_path):
    # 1. Seitenweise Extraktion mit pdfplumber
    # 2. Erhaltung von Zeilennummern
    # 3. Metadaten sammeln (Seitenzahlen)
    # Output: Liste von Text-Blöcken
```

**Phase 2: Struktur-Erkennung (`text_parser.py`)**
```python
def parse_drama_structure(raw_text):
    # 1. SUPER-PRECISE Akt-Erkennung mit Kontext-Validierung
    # 2. ULTRA-ACCURATE Szenen-Erkennung mit Nummerierung
    # 3. CHARACTER-PERFECT Sprecher-Erkennung (alle Varianten)
    # 4. INTELLIGENT Vers-Gruppierung (zusammenhängende Reden)
    # 5. CONTEXT-AWARE Vers-Nummerierung mit Qualitätskontrolle
    # Output: PERFEKT strukturierte Hierarchie
```

**Phase 3: Fußnoten-Bereinigung (`footnote_cleaner.py`)**
```python
def separate_footnotes_from_verses(text_blocks):
    # Regex-Patterns für Fußnoten:
    FOOTNOTE_PATTERNS = [
        r'\d+\s+\w+:\s+.*',        # "16 Gram: Kummer"
        r'vgl\.\s+Anm\.\s+zu',     # "vgl. Anm. zu V."
        r'\d+\s+[A-Z][a-z]+:',     # Nummerierte Erklärungen
    ]
    # Output: Saubere Verse + separierte Fußnoten
```

**Phase 4: EXTREME Quality Validation (`validators.py`)**
```python
def validate_structure(parsed_data):
    """ZERO-DEFECT validation - EVERY DETAIL CHECKED"""
    
    # 🎯 Structure Validation
    assert len(parsed_data) == 5, "Must have exactly 5 acts!"
    
    for act_num, act in enumerate(parsed_data, 1):
        assert act['number'] == act_num, f"Act {act_num} numbering error!"
        assert len(act['scenes']) > 0, f"Act {act_num} has no scenes!"
        
        for scene in act['scenes']:
            assert len(scene['stanzas']) > 0, f"Empty scene detected!"
            
            for stanza in scene['stanzas']:
                # ⚠️ CRITICAL: Check for footnote pollution
                for verse in stanza['verses']:
                    text = verse['text']
                    
                    # FAIL if ANY footnote markers found
                    assert not re.search(r'\d+\s+[A-ZÄÖÜ][a-zäöüß]*:', text), f"FOOTNOTE POLLUTION: {text[:50]}"
                    assert not re.search(r'vgl\.\s+Anm', text), f"REFERENCE POLLUTION: {text[:50]}"
                    assert not re.search(r'\(cid:\d+\)', text), f"PDF ARTIFACT: {text[:50]}"
                    assert not re.search(r'&#|&\w+;', text), f"HTML ENTITY: {text[:50]}"
                    
                    # Text quality checks
                    assert len(text.strip()) > 0, "Empty verse detected!"
                    assert not text.startswith(' '), "Leading whitespace error!"
                    assert not text.endswith(' '), "Trailing whitespace error!"
    
    # 🎭 Character Validation
    expected_characters = {'IPHIGENIE', 'THOAS', 'OREST', 'PYLADES', 'ARKAS'}
    found_characters = set()
    
    for act in parsed_data:
        for scene in act['scenes']:
            for stanza in scene['stanzas']:
                if stanza['title'].upper() in expected_characters:
                    found_characters.add(stanza['title'].upper())
    
    missing = expected_characters - found_characters
    assert not missing, f"Missing characters: {missing}"
    
    # 📊 Statistical Validation
    total_verses = sum(len(stanza['verses']) 
                      for act in parsed_data 
                      for scene in act['scenes'] 
                      for stanza in scene['stanzas'])
    
    # Iphigenie should have ~1800+ verses
    assert total_verses > 1500, f"Too few verses: {total_verses} (expected >1500)"
    
    print(f"✅ VALIDATION PASSED: {total_verses} verses, {len(found_characters)} characters")
    return True
```

**Phase 5: TypeScript-Export (`typescript_exporter.py`)**
```python
def export_to_typescript(validated_data):
    # 1. JSON-Struktur erstellen
    # 2. TypeScript-Interfaces generieren
    # 3. Formatierte .ts Datei schreiben
    # Output: iphigenieText.ts für React-App
```

#### **🎯 ULTRA-PRECISE Regex-Patterns (config.py)**
```python
# ⚡ PERFECT German Drama Structure Recognition
ACT_PATTERNS = [
    r'^\s*(ERSTER|I\.|1\.)\s+AUFZUG\s*$',
    r'^\s*(ZWEITER|II\.|2\.)\s+AUFZUG\s*$', 
    r'^\s*(DRITTER|III\.|3\.)\s+AUFZUG\s*$',
    r'^\s*(VIERTER|IV\.|4\.)\s+AUFZUG\s*$',
    r'^\s*(FÜNFTER|V\.|5\.)\s+AUFZUG\s*$'
]

SCENE_PATTERNS = [
    r'^\s*(ERSTER|I\.|1\.)\s+AUFTRITT\s*$',
    r'^\s*(ZWEITER|II\.|2\.)\s+AUFTRITT\s*$',
    r'^\s*(DRITTER|III\.|3\.)\s+AUFTRITT\s*$',
    r'^\s*(VIERTER|IV\.|4\.)\s+AUFTRITT\s*$',
    r'^\s*(FÜNFTER|V\.|5\.)\s+AUFTRITT\s*$',
    r'^\s*(SECHSTER|VI\.|6\.)\s+AUFTRITT\s*$'
]

# 🎭 CHARACTER Recognition - All Variants
SPEAKER_PATTERNS = [
    r'^\s*(IPHIGENIE|IPHIGENIA)\s*\.?\s*$',
    r'^\s*(THOAS|THOAS,\s+KÖNIG)\s*\.?\s*$',
    r'^\s*(OREST|ORESTES)\s*\.?\s*$',
    r'^\s*(PYLADES)\s*\.?\s*$',
    r'^\s*(ARKAS)\s*\.?\s*$',
    r'^\s*([A-ZÄÖÜ]{3,})\s*\.?\s*$'  # Fallback for other characters
]

# 🧹 NUCLEAR Footnote Destruction Patterns
FOOTNOTE_ANNIHILATION = [
    r'\d{1,4}\s+[A-ZÄÖÜ][a-zäöüß]*:\s+[^0-9]+?(?=\d{1,4}\s+[A-ZÄÖÜ]|$)',  # "16 Wort: Erklärung"
    r'vgl\.\s+Anm\.\s+zu\s+V\.\s*\d+[^0-9]*',  # References
    r'\[\d+\]\s*[^\[\]0-9]+',  # [16] markers with text
    r'Anm\.\s+\d+:.*?(?=Anm\.\s+\d+:|$)',  # "Anm. 16: text"
    r'\d+\)\s+[^0-9)]+(?=\d+\)|$)',  # "16) explanation"
    r'Fußnote\s+\d+:.*?(?=Fußnote\s+\d+:|$)',  # "Fußnote 16: text"
    r'\*+\s*[^*0-9]+',  # Asterisk footnotes
]

# 🧽 AGGRESSIVE Text Cleaning
CLEANUP_NUCLEAR = [
    r'\(cid:\d+\)',          # PDF artifacts 
    r'&#x?[0-9a-fA-F]+;',    # HTML entities
    r'&[a-zA-Z0-9]+;',       # Named entities
    r'[\u200b-\u200d\ufeff]', # Zero-width chars
    r'^\d+\s*',              # Line numbers at start
    r'\s*\d+\s*$',           # Line numbers at end
    r'\[\d+\]',              # Reference brackets
    r'\s{2,}',               # Multiple spaces
    r'\n{3,}',               # Multiple newlines
]

# ✨ German Text Quality Fixes  
GERMAN_FIXES = {
    # OCR corrections
    'ae': 'ä', 'oe': 'ö', 'ue': 'ü', 'ss': 'ß',
    'Ae': 'Ä', 'Oe': 'Ö', 'Ue': 'Ü',
    # Punctuation fixes
    ' ,': ',', ' .': '.', ' ;': ';', ' !': '!', ' ?': '?',
    ',,': ',', '..': '.', ';;': ';', '!!': '!', '??': '?',
    # Common OCR mistakes
    'rn': 'm', 'cl': 'd', 'li': 'h', 'vv': 'w'
}
```

#### **🚀 Hauptskript (main.py)**
```python
import click
from rich.console import Console

@click.command()
@click.argument('pdf_path', type=click.Path(exists=True))
@click.option('--output', '-o', default='iphigenieText.ts')
@click.option('--validate', '-v', is_flag=True)
def convert_pdf_to_typescript(pdf_path, output, validate):
    """
    Konvertiert Iphigenie PDF zu TypeScript-Format
    """
    console = Console()
    
    # Pipeline ausführen
    with console.status("PDF wird verarbeitet..."):
        # 1. PDF extrahieren
        # 2. Struktur parsen  
        # 3. Fußnoten bereinigen
        # 4. Validieren (optional)
        # 5. TypeScript exportieren
        
    console.print("✅ Konvertierung abgeschlossen!")
```

#### **⚡ Usage**
```bash
# Installation
pip install -r requirements.txt

# Konvertierung
python main.py iphigenie.pdf --output clean_iphigenie.ts --validate
```

## Target TypeScript Structure

```typescript
export interface Verse {
  id: string;
  text: string;
  lineNumber: number;
}

export interface Stanza {
  id: string;
  title: string; // Speaker name like "IPHIGENIE", "THOAS"
  verses: Verse[];
  act: number;
  scene: number;
}

export interface Scene {
  id: string;
  title: string; // Like "ERSTER AUFTRITT", "ZWEITER AUFTRITT"
  number: number;
  stanzas: Stanza[];
}

export interface Act {
  id: string;
  title: string; // Like "ERSTER AUFZUG", "ZWEITER AUFZUG"
  number: number;
  scenes: Scene[];
}

export const iphigenieText: Act[] = [...]
```

## 🏆 QUALITY CONTROL CHECKLIST

### ✅ **MANDATORY PRE-DELIVERY CHECKS**

Before outputting ANY TypeScript file, verify EVERY item:

#### **📝 Text Quality (ZERO TOLERANCE)**
- [ ] NO HTML entities (`&nbsp;`, `&amp;`, `&#x`, etc.)
- [ ] NO PDF artifacts (`(cid:2)`, weird symbols)
- [ ] NO footnote text mixed with verses
- [ ] NO reference markers (`vgl. Anm. zu V.`)
- [ ] NO empty verses or stanzas
- [ ] PERFECT German umlauts (ä, ö, ü, ß)
- [ ] PROPER punctuation spacing
- [ ] CLEAN whitespace (no leading/trailing spaces)

#### **🏗️ Structure Integrity**
- [ ] EXACTLY 5 acts (Aufzüge)
- [ ] All scenes properly numbered
- [ ] All characters correctly identified
- [ ] Continuous verse numbering
- [ ] Proper speaker assignments
- [ ] No duplicate IDs

#### **📊 Data Completeness**
- [ ] Total verses > 1500 (full drama)
- [ ] All main characters present (Iphigenie, Thoas, Orest, Pylades, Arkas)
- [ ] No missing scenes or acts
- [ ] Proper TypeScript syntax
- [ ] Valid JSON structure

#### **🎯 Example Perfect Verse**
```typescript
{
  "id": "verse-123",
  "text": "Heraus in eure Schatten, rege Wipfel", // ✅ Clean German text
  "lineNumber": 123
}
```

#### **❌ Example FAILED Verse (NEVER OUTPUT THIS)**
```typescript
{
  "id": "verse-123", 
  "text": "Heraus in eure Schatten, rege Wipfel 16 Wipfel: Baumkronen vgl. Anm. zu V. 45 (cid:2)", // ❌ GARBAGE
  "lineNumber": 123
}
```

### 🚨 **FINAL WARNING**
If ANY of these quality checks fail, DO NOT output the file. Fix the issues first. The React app depends on PERFECT data quality.

## Expected Result
A PERFECT, PRODUCTION-READY TypeScript file with ZERO defects, ready for immediate React e-reader integration!
